# 0X3B命令行参数

## 前置知识

* 0X32模块搜寻

## 正文

### Lua解释器

由于Lua语言小巧精悍的特性,它经常被用于写脚本.而它的执行环境也可以嵌入各种各样的语言和工程之中.不过,我们也可以把它作为一门独立的语言使用.这就是独立Lua.独立Lua的虚拟机由C语言写成,在Ubuntu,Arch等发行版的软件库中就可以下载到.如果需要,也可以去官网下载源码包自行安装.

演示: 源码安装Lua虚拟机 `<>!!!!!!!!!!!!!`

直接执行命令`lua`(或者`lua5.3`什么的),会启动交互式的Lua环境.从课程一开始我们就在这里实验代码.

`lua`命令后接文件名,会尝试用Lua虚拟机执行指定脚本.这种执行方法是一般的运行Lua程序的方法.交互模式和执行脚本这两种模式中,Lua的语法大致一致.但是会有一些执行细节上的区别,例如交互模式中美哟被接收的返回值默认会显示到终端,而脚本模式不会.又例如交互模式下,每一次执行命令,都当成一个chunk编译(哪怕是很多个简单的语句顺寻执行).

### 命令行参数

`lua`的命令行参数一般加到`lua`之后,要执行的脚本名之前.


参数`-e`后需要一个额外的字符串作为参数.会在执行脚本之前,把这个字符串作为Lua命令执行.例如创建脚本名为'test.lua'.其内容为:

>```lua
>print('x is',x)
>```

然后在命令行中执行

>```bash
>lua -e 'x=843' test.lua
>```

参数`-l`后也需要一个额外的字符串.它类似于`-e`.它的作用是把字符串当作模块名,在执行脚本(或者打开交互式环境)前require这个模块.例如创建脚本名为'test2.lua'.其内容为:

>```lua
>return 8899
>```

然后在命令行中输入:

>```bash
>lua -l 'test2'
>```

在启动的交互式环境中执行:

>```lua
>print(test2)
>```

参数`-v`会显示Lua的虚拟机(或者说解释器,编译器)的版本号.

### 交互模式

参数`-i`会在执行过脚本之后进入交互式编程环境.

退出交互模式一般有两种方法.一是输入文件终止符(EOF),一般类Unix系统shell下快捷键是C-d,Windows下的快捷键是C-z.

另一种方法是调用标准库中的函数os.exit.这个函数可以不带参数调用,也可以带参数.

>```lua
>os.exit(true)
>```

这个调用,推出状态为`EXIT_SUCCESS`.如果用`false`,则退出状态为`EXIT_FAILURE`.

其实它还可以接收第二个可选参数,如果第二个可选参数为`true`.则会在退出前关闭Lua state.至于Lua state是什么,可能要到介绍Lua和C的交互时会有所涉及.

### 环境变量设置

如果Lua虚拟机在启动时没有加参数`-E`,它会首先查找shell的环境变量`LUA_INIT_5_3`或者`LUA_INIT`.然后根据找到的shell环境变量设置Lua虚拟机的环境变量.

### 从标准输入流读取

如果输入以下命令.lua会把标准输入流当作一个文件读入.(一般Linux下,按EOF的快捷键C-d才能终止读入.)

>```bash
>lua -
>```

### 终止参数设置

为了防止混淆Lua虚拟机的参数,Lua脚本名和要传递给Lua脚本的参数,可以使用`--`显示终止虚拟机参数设置.

>```bash
>lua -e 'x=1245' -- -i
>```

这里`-i`不会被当作一个虚拟机参数处理.

### 运行脚本

除了显式指定虚拟机运行脚本.在类Unix系统上,还可通过改变Lua脚本文件的权限(例如`chmod 755 test.lua`)来直接通过文件名运行Lua脚本.

除了改变文件名,还需要在脚本文件首行加入一个特殊的不包含在Lua标准语法中的说明:

>```lua
>#!/usr/local/bin/lua
>```

这一行的作用是指定要用什么程序执行这个脚本.在井号和感叹号之后是我的lua虚拟机地址.如果你不太确定你的lua虚拟机安装路径可以尝试使用`which lua`命令查看.

改变文件模式,并添加说明行后.就可以直接运行脚本,例如:

>```bash
>./test.h
>```

## 后续推荐

* 

增补和拆分出0X3C系统函数

os.getenv (varname)

Returns the value of the process environment variable varname, or nil if the variable is not defined.

os.setlocale (locale [, category])

Sets the current locale of the program. locale is a system-dependent string specifying a locale; category is an optional string describing which category to change: "all", "collate", "ctype", "monetary", "numeric", or "time"; the default category is "all". The function returns the name of the new locale, or nil if the request cannot be honored.

If locale is the empty string, the current locale is set to an implementation-defined native locale. If locale is the string "C", the current locale is set to the standard C locale.

When called with nil as the first argument, this function only returns the name of the current locale for the given category.

This function may be not thread safe because of its reliance on C function setlocale.

剩下的在文件系统或者动态脚本中介绍.

6.9 – Operating System Facilities

This library is implemented through table os.

os.execute ([command])

This function is equivalent to the ISO C function system. It passes command to be executed by an operating system shell. Its first result is true if the command terminated successfully, or nil otherwise. After this first result the function returns a string plus a number, as follows:

"exit": the command terminated normally; the following number is the exit status of the command.
"signal": the command was terminated by a signal; the following number is the signal that terminated the command.
When called without a command, os.execute returns a boolean that is true if a shell is available.

os.tmpname ()

Returns a string with a file name that can be used for a temporary file. The file must be explicitly opened before its use and explicitly removed when no longer needed.

On POSIX systems, this function also creates a file with that name, to avoid security risks. (Someone else might create the file with wrong permissions in the time between getting the name and creating the file.) You still have to open the file to use it and to remove it (even if you do not use it).

When possible, you may prefer to use io.tmpfile, which automatically removes the file when the program ends.