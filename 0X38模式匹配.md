
### 匹配任意字符

考虑这个问题:要在str中匹配一个以a开头,b结尾的有三个字符的字符串.中间的字母是什么都可以(但是不能是数字或者其他非字母的符号).

针对每一个可能的子串写一个判断语句显然不合适.这时就要用到正则表达式的语法.在模式p中,'%a'会被当作一个有特殊意义的组合(转义).出现它的地方可以被任何一个字符代替.

尝试代码:

>```lua
>p='a%ab'
>string.find('aob')
>string.find('aeb')
>string.find('a%b')
>string.find('a%ab')
>```

类似于之前介绍过的各种字符串格式约定.正则表达式的组合还有很多.我们使用的'%a'这这张表中的符号成为字符类.也就是一个占位符表示可以匹配一类字符中的任何一个(逻辑的或关系).

| 组合 | 意义 |
| ---- | ---- |
| . | 表示任何一个符号(不论数字,字母或者其他) |
| %a | 表示任意字母 |
| %c | 表示任意ASCII中的控制字符 |
| %d | 表示任意数字 |
| %g | 表示ASCII中除了空格以外的所有可打印字符 |
| %l | 表示任意小写字母 |
| %p | 表示任意标点符号 |
| %s | 表示任意的空白符 |
| %u | 表示任意的大写字母 |
| %w | 表示任意字母或者数字 |
| %x | 表示任意十六进制数中用到的数字(除了十进制数字还包含几个字母) |

另外,在字符串`'^$()%.[]*+-?)'`中的这12个字符在正则表达式中有特殊的语法意义.如果想要匹配他们本身,必须在他们之前加上转义符'%'.

也可以给string.find传递第4个参数.当这个参数为true时.模式将被当成普通字符串进行匹配,不会解析其中的正则表达式.

>```lua
>str='aaabbba*ano'
>p='a*'
>string.find(str,p,1)
>string.find(str,p,1,true)
>```

### 自定义字符类

如果觉得预定义的字符类不能满足你的需求(比如你想要匹配1到5的数字或者字母abc),可以自定义字符类.

一个自定义的字符类以方括号开头结尾.方括号里的普通字符之间是或的关系.例如匹配a或b或c用:

>```lua
>p='[abc]'
>```

注意,这一长串其实只匹配一个位置.只是这个位置上的字符可以是a也可以是b也可以是c.

字符类的定义中如果要出现`'^$()%.[]*+-?)'`中的字符,也需要转义.

自定义的字符类中可以直接使用预定义子字符类.这样自定义的字符类就是预定义的字符类的超集.

对于数字和字母还有一个特殊写法,给出开头和结尾的字符,中间加上`'-'`则表示开头到结尾之间的所有字符.例如:

>```lua
>p='[a-e4-7]'
>```

表示小写字母a到e或者数字4到7.

如果自定义字符类要用排除模式,则在方括号内,一开始加上`'^'`.

>```lua
>p='[^1-3]'
>```

这个字符集表示除了数字1到3以外的所有字符.

对于预定义字符集,如果把表示它的字母换成大写,就表示反选字符集.例如'%a'表示所有字母,则'%A'表示所哟非字母.

### 匹配任意个字符

目前为止我们介绍的正则表达式可以匹配某个位置上的任意字符.但是无法匹配变长度的字符串.

在模式字符串中任意的字符或者字符类后加`'*'`表示匹配这个字符类零次或者任意次.例如:

>```lua
>p='a[bc]*d'
>string.find('abbbbbd',p)
>string.find('ad',p)
>string.find('acbcbd',p)
>```

类似的,`'+'`表示匹配一到任意次.

星号和加号都会匹配尽量长的字符串.而同样是匹配零到任意次的`'-'`则是尽量匹配短的.符号`'?'`则表示匹配零次或者一次.如果可能的情况下它会尽量匹配一次.

>```lua
>str='baaaaa'
>string.find(str,'ba*')
>string.find(str,'ba-')
>string.find(str,'ba?')
>```

### 匹配开头结尾

表达式`'%b'`后加两个字符.表示匹配一个字符串以`'%b'`后第一个字符开始,以第二个字符结束的字符串.例如匹配圆括号括起来的部分:

>```lua
>str='abc(ano)ee'
>string.find(str,'%b()')
>```

注意在`'%b'`后边两位出现正则表达式中有语法意义的特殊符号不需要转义,也不能使用字符类.

注意这个也会尽量匹配

### 边界检测

表达式`'%f'`后加一个自定义字符类.它返回的第一个值是一个属于这个类的字符的位置.而返回的第二个值只和第一个值差1,在这个位置上的字符是不属于指定的字符类的.例如:

>```lua
>string.find('aoeui12345','%f[%A]')
>```

### 捕获(Captures)

在模式中可以用括号括起来一部分模式.这部分模式将被"捕获".被捕获意味着在返回值的时候它们会作为额外的值返回.例如我需要获取一个被花括号括起来的子串.

>```lua
>str='nhn{aen}tgu'
>string.find(str,'%a*(%b{})%a*')
>```

在处理一些包含有重复内容的模式时,可以使用捕获的扩展功能.用'%'后加一个数字n.表示重复本字符串开始以来定义的第n个捕获(n必须是1到9以内的).例如:

>```lua
>str='cccab12ab12eee'
>string.find(str,'(ab)(12)%1%2')
>```

这里返回的头两个值匹配到的是'ab12ab12',然后返回'ab'和'12'.用数字引用捕获定义不会导致额外的返回值.


### 其他的匹配函数

除了string.find,正则表达式的模式字符串还能用于其他函数.

string.gmatch (s, pattern)这个函数会返回一个迭代器,其中包含了s中所有符合pattern的子串.

string.match(s,pattern)会返回检测到的第一个符合pattern的s的子串,即使没有使用捕获表达式.可以接受第三个参数用于指定搜索的起点.

string.gsub(s,pattern,repl)不会改变s本身.但是它的返回值是把s中所有符合pattern的地方都用替换.

如果repl是字符串,则用repl替换.如果repl中含有捕获中百分号加数字的写法,这些占位符会被捕获的子串替换.如果是`'%0'`表示整个匹配到串.`'%%'`表示一个百分号.

如果repl是函数,每次替换都会调用这个函数并且用函数返回值替换.在调用函数的时候,会把捕获到的字符串作为参数传递给函数.

如果repl是表,则在每次替换的时候会先用第一个捕获到的字符串在表中查表,然后把返回值用于替换.(查表结果或者函数返回值为为false或者nil则不会替换,原字符串这一部分保持原样.)

在任何情况下如果没有模式pattern没有指定捕获则进行普通文本替换.