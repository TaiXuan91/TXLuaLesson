# 0X37搜寻字符串

## 前置知识

* 0X32模块搜寻

## 正文

### 问题的提出

在模块搜寻中,我们说到lua会在目录下搜索文件名,找到和需要导入的模块名称匹配的.如果你需要自己实现一个类似的功能,像没有用任何字符串处理库的C语言那样逐个字符比较固然可以.但是更高效的做法是使用字符串模式匹配技术.在这节我们要介绍正则表达式就是一种此类技术的实现.

### 简单的查找

先看一个简单的例子,我们搜索字符串,查看它是否含有指定字符串.一般来说如果一个文件名中含有某个关键词,我们就会认为这个文件名可能和关键词关联的主题有关系.

>```lua
>str='abcaoeudndogahoeantga'
>p='dog'
>string.find(str,p)
>```

这里的str是被检查的字符串.p是我们希望在str中找到的东西,称为模式(pattern).这里我们直接以字符串'dog'作为模式,所以就会在str中搜寻有没有'dog'.

string.find函数的作用就是在str中搜寻p.如果找到就返回第一个匹配的位置(两个返回值,匹配到的位置的开头和结尾,都以数字形式返回,默认第一个字符是1号.)如果没有找到就返回一个nil.

有时候我们希望不要从str的开头开始查找,就可以给string.find第三个参数.它会指定搜索开始的位置.

>```lua
>str='abcdogabcdog'
>p='dog'
>i=5
>string.find(str,p,i)
>```

字符串str中有两个子串'dog',但是由于从第5个字符开始匹配,这里会匹配到第二个子串'dog'.如果这个参数是负数,表示从倒数第几个字符开始匹配.

### 匹配任意字符

考虑这个问题:要在str中匹配一个以a开头,b结尾的有三个字符的字符串.中间的字母是什么都可以(但是不能是数字或者其他非字母的符号).

针对每一个可能的子串写一个判断语句显然不合适.这时就要用到正则表达式的语法.在模式p中,'%a'会被当作一个有特殊意义的组合(转义).出现它的地方可以被任何一个字符代替.

尝试代码:

>```lua
>p='a%ab'
>string.find('aob')
>string.find('aeb')
>string.find('a%b')
>string.find('a%ab')
>```

类似于之前介绍过的各种字符串格式约定.正则表达式的组合还有很多.我们使用的'%a'这这张表中的符号成为字符类.也就是一个占位符表示可以匹配一类字符中的任何一个(逻辑的或关系).

| 组合 | 意义 |
| ---- | ---- |
| . | 表示任何一个符号(不论数字,字母或者其他) |
| %a | 表示任意字母 |
| %c | 表示任意ASCII中的控制字符 |
| %d | 表示任意数字 |
| %g | 表示ASCII中除了空格以外的所有可打印字符 |
| %l | 表示任意小写字母 |
| %p | 表示任意标点符号 |
| %s | 表示任意的空白符 |
| %u | 表示任意的大写字母 |
| %w | 表示任意字母或者数字 |
| %x | 表示任意十六进制数中用到的数字(除了十进制数字还包含几个字母) |

另外,在字符串`'^$()%.[]*+-?)'`中的这12个字符在正则表达式中有特殊的语法意义.如果想要匹配他们本身,必须在他们之前加上转义符'%'.

也可以给string.find传递第4个参数.当这个参数为true时.模式将被当成普通字符串进行匹配,不会解析其中的正则表达式.

>```lua
>str='aaabbba*ano'
>p='a*'
>string.find(str,p,1)
>string.find(str,p,1,true)
>```

### 自定义字符类

如果觉得



### 匹配任意个字符

Lua的模式匹配会匹配尽量长的字符串

## 后续推荐