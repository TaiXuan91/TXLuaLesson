# 0X2C表的遍历

## 前置知识

* 0X25表嵌套
* 0X2B循环for

## 正文

1. 在编程中经常遇到需要对表中的所有成员都进行处理的情况.这称为表的遍历.
1. 为了方便,我们先讨论顺序列表.它们中的索引都是正整数,而且连续.
    * 所谓的"连续"是指不会出现前两个索引对应值为非nil值,中间两个索引对应值为nil,后边又有索引对应的值为nil.
    * 事实上,如果一个表不连续,或者有非正整数的索引不会影响ipairs,长度运算#等的表现.只是不会把不连续的部分(第一个为nil值的正整数索引以后的部分)或者非正整数索引的部分算进去而已.例如以下代码显示2.
        >```lua
        >list={23,322,oeu=233}
        >list[29]=67
        >print(#list)
        >```
1. 遍历顺序列表可以通过之前学过的循环语句完成.循环次数等于表长.循环变量的初始值是1.并且在每次的循环中,循环变量的值作为索引.逐一回顾(或者拓展)一下我们所要用到的知识点(假设已有`list={23,82,12}`):
    * 取长度运算#可以作用于字符串或者顺序列表.用于返回其长度.例如`#list`.
        * 除了使用运算符#,也可以使用函数rawlen来获取字符串或者表的长度.``
    * 可以用变量的值作为列表的索引.例如
        >```lua
        >i=2
        >list[i]
        >```
1. 例如输出一个顺序表中的所有连续的索引和内容:
    >```lua
    >list={23,12,343,432}
    >list[5]=2322
    >for i=1,#list do 
    >    print(i,list[i])
    >end
    >```
1. for语句的另一种写法可以更加简洁地实现遍历表的功能.关于这种写法我先给出用法.其原理想要阐述清楚可能需要花费不少篇幅.所以放到以后介绍.
1. 我们在介绍for的另一种写法之前.先来介绍所谓的迭代器.所谓的迭代器实际是一个或者一组函数(在Lua中是一个函数,一个表和一个值).
    * 目前来说迭代器的作用就是用在for循环里,用于遍历表.
    * Lua中的一些库函数会返回迭代器.例如pairs,ipairs,utf8.codes.
1. ipairs函数接受一个顺序列表作为参数,返回一个迭代器.配合for语句可以遍历顺序列表中所有成员.
1. 给出一个for遍历的例句:
    >```lua
    >for k,v in ipairs(list) do 
    >    print(k,v)
    >end
    >```
    可以看出,这种for语句和之前的不同在for到do之间的这一段.这个语句会输出list中的所有连续的索引k和其对应值的值v.
1. 关于8中的例程.
    * ipairs(list)这里返回一个表list的迭代器.可以先不用关心它究竟是什么.先当作一种特定写法.
    * k是索引,v是索引对应的值.它们相当于之前写法中的循环变量i和用i当索引在list表中得到的结果list[i].
    * k和v也可以叫别的名字.它们是for语句创建的两个局部变量.不论叫什么,第一个都会被赋予索引,第二个变量都会被赋予对应的值.
1. pairs函数的效果和ipairs相似.不同的是,它会把表中所有值不为nil的键值对都遍历到.包括不连续的正整数索引和非正整数索引.实验:
    >```lua
    >list={12,'2332',3432,abc=oeu,cc=oe}
    >list[78]='hello'
    >for i,v in ipairs(list) do
    >    print(i,v)
    >end
    >for i,v in pairs(list) do
    >    print(i,v)
    >end
    >```
1. 最后这里简单说明一下迭代器是什么.如果看不懂可以跳过.
    * 在Lua中ipairs和pairs函数都会返回三个返回值.
        >```lua
        >a,b,c=ipairs(list)
        >print('list:',list)
        >print('a,b,c',a,b,c)
        >```
    * 第一个是一个函数,第二个是要遍历的表本身,第三个是遍历的起点.
    * 其中的遍历起点一般是0(pairs是nil).如果不是0,则在遍历时就以这个索引为起点(遍历时不访问起点本身).
    * pairs遍历的表的索引看似是不用排序的.但是系统内部按照一定的规则把所有的非数字索引成员也排了序.pairs在遍历非数字索引成员的时候就按照这个系统内部的顺序遍历.
    * 本质上Lua中表便利的语法应该这样写(为了明显我这里直接用list和0取代了b和c,如果a是由pairs返回的函数,则c的位置上应该是nil).
        >```lua
        >for i,v in a,list,0 do print(i,v) end
        >```
    * 最后来说说a.这个函数接受两个参数:一个表和一个索引值.它也返回两个值,这两个值是表b中的一组键值对(索引和索引对应的值)例如:
        >```lua
        >i,v=a(b,c)
        >```
    * 函数a的返回值其实是一个两次查表的过程.它接受的参数b是一张表,它内部还有一张表(通过闭包保存的,假设叫x).它返回的是:
        >```lua
        >return x[c],b[x[c]]
        >```
    * 对于ipairs,x的长度等于#list.对于pairs,x的长度等于表的总元素个数.
    * 把所有的要遍历的键值对的键按照系统内默认的顺序排好.按照如下方法生成x:
        * 0作为索引时对应值为原来的表的第一个索引.(pairs需要用nil,这是函数内部进行了一次判断分情况给出了返回值.nil不能直接作为表的索引.)
        * 第一个索引作为索引时对应值为原来的表的第二个索引.第二个索引对应第三个,第三个对应第四个以此类推.
        * 最后一个索引作为索引时,对应值为nil.
    * 引入x之后就能实现以下三点:
        * 对于pairs来说把不连续的表整合成一张表.对于ipairs来说把不连续的键值对剔除.
        * 返回值的同时能返回键(因为原来的键和值现在都成了值.)
        * x[cc]会返回排在cc后边的那一个键.在把这个键代进去又能获得下一个.从而推动遍历.(0或者nil作为第一个cc的值.每次都更新cc=x[cc].直到x[cc]等于nil,则遍历结束.)
    * ipairs和pairs这两个函数生成器封装了上述过程.
    * 以上过程是根据ipairs和pairs的表现逆向猜测出来的.由于Lua虚拟机由C语言实现.所以一些机制的实现其实不应当用Lua的概念来解释.

## 后续推荐

* 0X2D对表操作