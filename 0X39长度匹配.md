### 匹配任意个字符

目前为止我们介绍的正则表达式可以匹配某个位置上的任意字符.但是无法匹配变长度的字符串.

在模式字符串中任意的字符或者字符类后加`'*'`表示匹配这个字符类零次或者任意次.例如:

>```lua
>p='a[bc]*d'
>string.find('abbbbbd',p)
>string.find('ad',p)
>string.find('acbcbd',p)
>```

类似的,`'+'`表示匹配一到任意次.

星号和加号都会匹配尽量长的字符串.而同样是匹配零到任意次的`'-'`则是尽量匹配短的.符号`'?'`则表示匹配零次或者一次.如果可能的情况下它会尽量匹配一次.

>```lua
>str='baaaaa'
>string.find(str,'ba*')
>string.find(str,'ba-')
>string.find(str,'ba?')
>```

### 匹配开头结尾

表达式`'%b'`后加两个字符.表示匹配一个字符串以`'%b'`后第一个字符开始,以第二个字符结束的字符串.例如匹配圆括号括起来的部分:

>```lua
>str='abc(ano)ee'
>string.find(str,'%b()')
>```

注意在`'%b'`后边两位出现正则表达式中有语法意义的特殊符号不需要转义,也不能使用字符类.

注意这个也会尽量匹配

### 边界检测

表达式`'%f'`后加一个自定义字符类.它返回的第一个值是一个属于这个类的字符的位置.而返回的第二个值只和第一个值差1,在这个位置上的字符是不属于指定的字符类的.例如:

>```lua
>string.find('aoeui12345','%f[%A]')
>```

### 捕获(Captures)

在模式中可以用括号括起来一部分模式.这部分模式将被"捕获".被捕获意味着在返回值的时候它们会作为额外的值返回.例如我需要获取一个被花括号括起来的子串.

>```lua
>str='nhn{aen}tgu'
>string.find(str,'%a*(%b{})%a*')
>```

在处理一些包含有重复内容的模式时,可以使用捕获的扩展功能.用'%'后加一个数字n.表示重复本字符串开始以来定义的第n个捕获(n必须是1到9以内的).例如:

>```lua
>str='cccab12ab12eee'
>string.find(str,'(ab)(12)%1%2')
>```

这里返回的头两个值匹配到的是'ab12ab12',然后返回'ab'和'12'.用数字引用捕获定义不会导致额外的返回值.


### 其他的匹配函数

除了string.find,正则表达式的模式字符串还能用于其他函数.

string.gmatch (s, pattern)这个函数会返回一个迭代器,其中包含了s中所有符合pattern的子串.

string.match(s,pattern)会返回检测到的第一个符合pattern的s的子串,即使没有使用捕获表达式.可以接受第三个参数用于指定搜索的起点.

string.gsub(s,pattern,repl)不会改变s本身.但是它的返回值是把s中所有符合pattern的地方都用替换.

如果repl是字符串,则用repl替换.如果repl中含有捕获中百分号加数字的写法,这些占位符会被捕获的子串替换.如果是`'%0'`表示整个匹配到串.`'%%'`表示一个百分号.

如果repl是函数,每次替换都会调用这个函数并且用函数返回值替换.在调用函数的时候,会把捕获到的字符串作为参数传递给函数.

如果repl是表,则在每次替换的时候会先用第一个捕获到的字符串在表中查表,然后把返回值用于替换.(查表结果或者函数返回值为为false或者nil则不会替换,原字符串这一部分保持原样.)

在任何情况下如果没有模式pattern没有指定捕获则进行普通文本替换.