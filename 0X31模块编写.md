# 0X31模块编写

## 前置知识

* 0X30模块调用

## 正文

### 1. 回顾脚本

回顾之前在脚本编写上的内容.脚本需要在命令行中直接指定运行.但是当程序比较大的时候,把所有代码都放到一个文件中就会难以管理和编辑.需要把程序分割成很多个相对独立的部分进行管理.

另外,在编写程序时有很多通用的代码(例如在一个程序的很多部分中或者很多程序中都能用到的函数).我们希望把这些通用性的代码可以独立编写成一个文件在需要的时候进行调用.

### 2. 模块脚本

在Lua中通过模块来实现之前讨论的功能.模块是一种不需要直接从命令行执行的脚本.一般来说,这种脚本中会定义一个表.在脚本中给这个表增加各种成员.在脚本的最后利用return语句把这个表返回.这个表就是在模块调用语句返回的表.

关于return语句请注意,这个return语句不包含在任何的代码块(函数定义,流程控制复合句)之中.(从整体上看,一个脚本也就相当于一个特别大的函数.)

在模块脚本所在的位置打开Lua虚拟机.然后使用模块调用函数require调用刚刚编写好的模块.模块脚本文件的名称(不包括后缀".lua")就是模块的名称.

演示: 模块的编写和调用 `<>!!!!!!!!!!!!!!!!!!!!!!!!!!!`

注意,一般来说模块脚本的文件名(不包括后缀".lua"的部分),模块脚本中的表的名称应当一致.

### 3. package模块

package模块是一个Lua标准库中的模块.如果这个模块的内容不能正常使用,请先执行

>```lua
>require('package')
>```

package.loaded是一张表.其成员是所有已经加载的模块.在require函数执行时,如果发现loaded中有同名成员,则require不再执行模块脚本,而是直接返回loaded中的对应值.

与package.loaded类似的有一个package.preloaded表.require也会先查询它,如果在其中找到同名成员,就把这个成员作为require的结果返回.但是这个表中一般都是存放特殊的预加载模块.一般不涉及这个表的使用.

一般来说模块脚本中定义的所有变量(包括返回的表本身)应当用local修饰.这样执行过模块加载过程后不会污染当前的变量名称(不会无意中改变同名变量的值).但是如果这样做,仅仅执行require而不把其返回值赋予变量,就无法用和模块名相同的名称访问这个表(这点和标准库中的模块不同).

因此为了避免一系列问题,模块的引用应当写成这样的形式:

>```lua
>packagename=require('packagename')
>```

### 4. 搜寻模块

当调用require时,其实Lua要分好多步骤在多个地方查找有没有同名模块.在一个地方找不到就去下一个地方寻找.package.searchers这张表中定义了这些步骤和步骤的执行顺序.现在按其中函数的顺序索引依次介绍:

1. 第一个函数最先执行,它在package.preload表中搜寻.
1. 第二个函数在指定路径中搜寻Lua的脚本文件并加载这些模块.
1. 第三个函数在指定的路径中搜寻C语言编译后的库文件并加载这种模块.关于Lua和C语言的交互我们将在后边进行讨论.
1. 第四个函数也和C库的加载有关.

### 5. 搜寻路径

require在搜寻模块脚本文件的时候是在一些指定的路径之下搜寻的.这些路径保存在字符串变量package.path中,如果你的模块文件所在路径恰好不在这些路径这下可以,通过追加package.path的方法把自己的模块脚本所在路径添加进去.

例如我希望把"/home/myname"文件夹下的所有后缀名为"luna"的文件识别为Lua的模块脚本就执行:

>```lua
>package.path=package.path..';/home/myname/?.luna'
>```

这里有几个符号的约定:

* "/"用于表示目录层次关系.在Windows系统中这个符号会变为"\".
* ";"用于分割两个目录.package.path是一个整个字符串,但是其中包含多个路径.不同的路径中用";"进行分隔.这里的演示代码是追加path变量(而不是彻底重置),所以需要把我们追加的路径前加一个分号,用于和原来的路径分隔开.
* "?"路径中的问号是个占位符.在实际搜索中它会被require的参数替换.例如我们调用`require('mymod')`时实际在找"/home/myname/mymod.luna"等文件.

以上符号都是在字符串package.config中设置的.在这个变量中还额外设置了一个用于Windows环境中的特殊符号"!"和一个用于和C语言互动的符号"-".(和C相关的内容以再介绍.)

### 6. 搜寻原理


package.searchpath (name, path [, sep [, rep]])

Searches for the given name in the given path.

A path is a string containing a sequence of templates separated by semicolons. For each template, the function replaces each interrogation mark (if any) in the template with a copy of name wherein all occurrences of sep (a dot, by default) were replaced by rep (the system's directory separator, by default), and then tries to open the resulting file name.

For instance, if the path is the string

     "./?.lua;./?.lc;/usr/local/?/init.lua"
the search for the name foo.a will try to open the files ./foo/a.lua, ./foo/a.lc, and /usr/local/foo/a/init.lua, in that order.

Returns the resulting name of the first file that it can open in read mode (after closing the file), or nil plus an error message if none succeeds. (This error message lists all file names it tried to open.)


## 后续推荐
