# 换用Haskell

上回说到我有一个大胆的想法。要实现这个大胆的想法第一步就是构造一个功能强大的字符串处理工具库。

如果你是在纸上玩这些游戏，那么自然不需要这些工具。因为你可以把这些规则都记忆在脑中然后人工地按照规则去抄写字符串。但是如果要用机器来玩这个游戏，字符串处理就是必不可少的功能。而Lua提供的字符串处理功能又略显单薄。因此我选择换一门更方便一点的语言——Haskell。

可能你之前了解过Haskell，知道它是纯函数式编程语言什么的。但是这里我们不管，仅仅把它当作一个用于实现我们游戏的字符串解析工具。

接下来我们开始用Haskell构造我们的游戏。如果其中涉及的Haskell代码看不懂，请不要慌。因为我们后续还会详细介绍Haskell语言。

## 无穷的变量名

即使你对于“变量”没有一个具体的认识，你也应该在数学中用过变量。关于变量代表什么我们以后再说。现在我就直接使用“变量”这个词。而“变量名”则表示变量的名称。

数学上的变量名用得很随意。但我们这里为了统一，不使用$x, y, z$等符号。而使用字母$v$加下标的变量名生成方式，例如$v_1, v_2, v_3, v_4...$。这样字母$v$加整数下标，实际上能得到可数无穷个变量名。这对于我们来来说已经足够了。

由于纯文本中没有下标，所以我们变化一下写法，写成`v1, v2, v3`等形式。

另外，出于方便考虑，我进一步把`v1, v2, v3`改写成`Var 1, Var 2, Var3`的样子。这里的`Var 3`就相当于之前的变量$v_3$。那为什么非要写成`Var 3`这种形式呢？这是因为这种形式恰好和Haskell中的语法相合。我们可以直接用Haskell中的值构造器来生成变量。

构造变量名的代码其实很简单，如下所示：

```haskell
data Variables = Var Integer
  deriving (Eq, Ord, Show, Read)
```

这里对代码进行一些解释，如果你看不懂可以跳过这一小段。在实现这个“大胆想法”的过程中，所有的Haskell代码讲解都这样处理。

上边的代码中，实现了`Ord`类。这是因为后续的程序中要调用`Data.Set`。而`Data.Set`提供的`Set`数结构需要成员实现了`Ord`。

> 要求集合成员实现`Ord`从数学上看来是一个很无理的要求。但是计算机只能处理可数的数据，因而这里的`Set`是基于`[]`（列表）实现的。因而要求有序。
>
> 从另一方面来说，`Data.Set`中的这个`Set`并不能完全等同于一般数学定义上的`Set`。

好的，代码的讲解就现到这里。接下来演示一下如何使用。

首先，我们当然可以直接用Haskell的语句来定义新变量。例如：

```haske
x = Var 3
y = Var 7
```

我们也可以把字符串转化为变量：

```haskell
x = (read "Var 3")::Variables
y = read "Var 7" :: Variables
```

如果要把Variables转化为字符串，可以这样写：

```haskel
show x
show y
```

## 构造表达式

变量名是一种词。仅凭这种词还不能完成“造句”的工作。在手写形式的Lambda演算中我们需要$\lambda$，$.$这两个符号和变量名一起构成表达式。为了可读性还会加上$($和$)$这两个辅助符号。

由于Haskell的语法规则限制，我们难以直接套用手写形式的符号。所以在我将要构造的系统中，我们使用符号`:.`，`:=>`，`(`，`)`，`VE`以及变量名一同构成表达式。



仅仅把Haskell当作一个简单的字符串解析工具（因为能够实现read）

先实现Lambda，然后引入类型系统

然后介绍haskell

参考那个电子书以及

<https://plato.stanford.edu/entries/lambda-calculus/>

（介绍type lambda的时候尽量减少预定义类型)