# 文字游戏

## 一道小学数学题

我记得在小时候的数学书上，有过这样的数学题：
$$
\square + \square + \square = \triangle  \\
\square + \square +\triangle = \bigcirc \\
\bigcirc + \square = \triangle + ?
$$
请问第三个等式中，问号处应该填一个什么图案使得等式成立？

三个等式中没有出现一个数字，但这毫无疑问是一道数学题。因为只要把式子中的符号稍作替换，我们就会发现这实际上是一个方程或者算术问题。

如果替换成代数符号，那么式子就变成：
$$
x+x+x = y\\
x+x+y = z\\
z+x=y+?
$$


我们也可以替换成阿拉伯数字，这下问题显得更简单了：
$$
1+1+1 = 3 \\
1+1+3 = 5 \\
5+1 = 3+?
$$
很明显，答案是$3$。对于代数符号版的式子，答案则是$y$。对于原版问题来说，答案则是$\triangle$。在这个问题中，$3$，$y$和$\triangle$其实扮演者同样的角色。

虽然我们变换了问题的表达形式，但这没有改变问题的实质。在变换的表象之下是不变的本质。$3$，$y$和$\triangle​$这些东西就是变换的表象。而透过他们展示给我们的就是不变的本质。

## 具象和抽象

我不知道生活是不是这样。但是至少在数学中，我们实际上会接触到两个世界。一个是图像，声音，文字等所组成的，易于变换的具象的世界。另一个看不到摸不着，无论具象世界如何变换都不受影响的抽象的世界。数学旨在研究这个抽象世界，但是抽象世界没有形体，无法捉摸。因此需要建立具象世界和抽象世界的联系，借由研究具象世界，来研究抽象世界。

我再来举一个简单的例子。“两个苹果”，“二升汽油”，“地球和月球”这三样东西看起来风马牛不相及。但是，我总觉得它们之间有一些共性的特征。只不过这个特征停留在那个“抽象的世界”，我无法直接把它指出来。因此我需要从具象的世界里找一个与之联系的事物。所以我就写了一个符号，并且约定，用这个符号来表示这种性质。这个符号就是“2”。

当然，别人也许会用“俩”，“双”，“two”，“に”，“⚁”，“10”等别的符号来表示它。但这都没关系，这些符号本质上都在表示同一种性质。而且用什么符号其实都没关系，只要在交流的时候，你我知道“2”这个符号表示那种（“两个苹果”，“二升汽油”，“地球和月球”共有的）性质就可以了。

> 把抽象概念和具体符号联系起来这一动作，可以称之为“绑定”。

## 仅仅有符号

当我们完成符号的约定之后，实际上我们就可以完全不必考虑那个难以捉摸的抽象世界，完全把注意力放到都问定义的这些符号上来。

最开始我学习加减法的时候，还需要比对“三个苹果吃掉两个”这种实际情景。因为那时候我还不太熟悉这套由前人约定好的符号规则。但是当我把加法表熟记于心的时候，不论问题的实际背景是什么，我仅仅需要数字就可以计算出结果。我所作的工作仅仅是把看起来像是$3-2$的符号替换为$1$，然后抄写一遍。这个有点玄乎的，涉及“抽象”的过程，对于学会使用阿拉伯数字进行加减运算的我来说成了一个文字替换游戏。

实际上，不仅仅是加减法。整个数学学科，其实就是一场又一场的“文字游戏”。数学家们定义很多符号，然后把这些符号抄来抄去，替换，合并，拆分，消除。从具象的角度来看，这就是这么多年来数学家们所做的事情。

我写这个系列文章的目的，就是简单介绍一下，这些文字游戏怎么玩。

## 节约纸张的Haskell

最经典的文字游戏玩法，当然是亲自用纸笔抄抄写写，勾勾画画。但是我不想把大把时间消耗在抄写字符上。我想把这些枯燥、机械的动作交给别人来处理，而我只关注游戏中比较有意思的部分。幸好，我这个需求，在将近一百年前就有解决方案了——做一台机器，让机器按照我的指引完成抄写。

![图灵机模型](https://upload.wikimedia.org/wikipedia/commons/thumb/a/ad/Model_of_a_Turing_machine.jpg/1280px-Model_of_a_Turing_machine.jpg)

出于节约纸张的目的，我并不想直接用这种还需要用纸的机器。因此我使用另一种不需要消耗纸带，但是同样能按照我的指示自动完成抄写的神奇机器——Haskell——来进行游戏。

> 真正要使用Haskell，你得准备计算机硬件和操作系统，然后安装Haskell编译器。但是这里我不想深入探讨这些细节，就把它们整个当作一个名为Haskell的机器。

## 名词，代词和动词

现在我们有了进行游戏的工具，就可以探讨一下如何将之前提过的抽象的世界和我们正在摆弄的文字符号联系起来了。

### 名词

首先我们需要名词。一个名词对应抽象世界中的某一个东西。比如抽象世界有一个“表示两个”的概念，我们在Haskell中就指定一个符号`2`来表示它。抽象世界中有一个“表示逻辑真”的概念，我们在Haskell中就可以指定`True`来表示它。这些词就是我们的“名词”。不过在Haskell中一般不这么称呼它们，我们会称之为“值构造器”。

叫它们“构造器”而不叫“词”是有原因的。我们把抽象世界中“两个”，“三个”，“真”，“假”这些概念称为“值”。因而我们的名词肯定不能再称为“值”。这些名词只是“值”的附属，一种表示“值”的东西，而非“值”本身。所以我们应该起名为“值某某”。比如“值表示符”，“值指代词”等。但是为什么最终选择了“值构造器”这个感觉怪怪的名字呢？这是因为Haskell是一种纯函数式语言。函数式语言的一个传统就是尽量把所有东西都和函数扯上关系（就像面向对象语言尽量把一切都和类对象扯上关系一样）。因而这些名词不被当作一种简单的常量，而被当作一种恒定输出的常函数。按照编程中的命名习惯，如果某一种值只能通过几个函数构造得到，那么就称这些函数为“构造函数”或者“构造器”（如果你知道面向对象中的“构造函数”，你就能很快接受这个设定）。因而，我们称这些名词为“值构造器”。

> 函数式编程语言的鼻祖是Lambda Calculus。在Lambda Calculus中一切东西都都是函数。所以后续所有的函数式编程语言都试图达到这种统一。

把名词称作“值构造器”，其实隐含着这样一种思维——当我使用一个值的时候。实际上并不是直接把值写了出来（因为值是抽象的，不能直接写出来）。而是调用了值构造器。值构造器在调用它的地方返回了一个它能构造的值。

> 对于组合类型的值（比如C语言种的“结构体”），它们的构造器是需要接受参数的。即使是在类C语言中我们也经常写一个构造函数来构造这些值。但是对于一些原子类型，比如整数和字符，这个用构造器构造的思路就比较难以理解。可以这样理解——这些值的构造器，是输入参数列表为空（不需要输入参数），输出恒定的常函数。用类C语法表示整型数值“1”的构造器，看起来就像这样：
>
> ```C
> int One(void){
>  return 1;
> }
> ```
>
> 但是从类型上来说，不带参数的构造器的类型并不是`Void -> Int`之类的。因为Haskell中并没有`Void`这种类型。写成`->Int`又违背了符号`->`在Haskell中的用法。因而这种构造器的类型就是`Int`。

### 代词

考虑这样一个简单的文字替换游戏。有一串字符“X是Y。Y都会Z。所以X会Z。”。我们把其中的“X”替换为“苏格拉底”，“Y”替换为“人”，“Z”替换为“死”，就得到了“苏格拉底是人。人都会死。所以苏格拉底会死。”。如果把“X”替换为“太玄”，“Ｙ”替换为“鸽子”，“Z”替换为“咕咕咕”。那么就得到了“太玄是鸽子。鸽子都会咕咕咕。所以太玄会咕咕咕。”这俩句子在形式上都没毛病。

在这个游戏中，“X”，“Y”，“Z”本身没什么意义。只要它们能彼此区别，占住位置，以供有实际意义的词替换就可以。我们完全可以用“甲乙丙”，“$\bigcirc \square \triangle$”或者别的什么来替代这三个字母的作用。这里的“X”，“Y”，“Z”，就是代词。它们的用途和自然语言中的“她他它”类似。凡是有“她他它”的句子，把“她他它”这些词换成对应的名词都是可以的。例如“我想聊聊酒石酸。他是个勤奋的Up主。”中，后一句可以替换为“酒石酸是个勤奋的Up主”。

一般来说，语法书或者代数课本上可能会告诉你。代词（或者代数符号），提供了泛指的能力，而不像名词那样总是指某一个事物（一个类别对数学来说也只是“一个”概念）。但是我想提供点其他思路。我认为应当说代词比名词更基本，更普遍。先有代词，后有名词。有一部分代词固定下来就成了名词。

一开始只有，代词。而一个代词可以指代任何东西。我们通过加限定的方式来限制代词可以指代的范围。比如$x(x\in R)$，这就把$x$的指代范围限制到了实数集中。更进一步$x (x \in R, x>5)$这样又限制$x$的纸带对象必须大于$5$。有时候限制会比较严格，所以代词实际上只能指一个对象。例如$x (\forall y (y\notin x))$，这里的$x$虽然还当作代词看代，但是实际上它只能指代空集。

关于数学的研究，讨论和应用相当于一个大语境。在这个语境中，我们默认存在一条这样的声明$\emptyset(\forall y(y\notin \emptyset)) $。因此在这个语境中代词$\emptyset$的指代就固定下来。这样，代词就成了名词。

弄清代词和名词的关系之后，我们回到Haskell中。在Haskell里代词被分为了两种。一种是大写字符开头的构造器名，一种是小写字符开头的变量名。构造器名只能用于绑定到某个对象上，当作名词使用。而变量名不管绑定了几个对象，始终被当作代词。或者说简单一点，构造器名是名词，变量名是代词。

> Haskell中小写字符包括小写英文字母，下划线以及Unicode中其它语言的小写字母。大写字符包括大写英文字母以及Unicode中其他语言的大写字母。

> 在Haskell中值构造器其实不仅仅有字母开头的。字面值`1`，`2`，`"hello world"`等也可以理解为值构造器，这点我们以后会详细说明。

### 动词

在自然语言中，动词是十分重要的词类。尤其是曲折语当中，动词除了要充当谓语撑起句子的半边天，还要通过格的变化表示人称，时间，语气，方位等等信息。

如果用编程语言和自然语言比对。在类C编程语言中。变量和常量相当于名词性词汇，而函数相当于动词。在Haskell中，也是用函数充当动词。这一点上C和Haskell倒是达成了共识。

![似乎达成了共识](./README.assets/250px-似乎达成共识.png)

不过请注意，Haskell是函数式语言。函数式语言希望一切都是函数。所以有些东西，比如“1”,“2”，“True”，“False”，表面上看起来是名词，实际上也是动词。

![拒绝达成共识](./README.assets/拒绝达成共识.jpg)

> 常量都是构造器，而变量都指代构造器。而构造器本质都是函数。所以实际上所有值构造器和指代值构造器的都是“动词”。也就是说，基本上Haskell中所有词都是动词，同时也是名词。
>
> 可能你会反驳我说“1”，“2”，“True”，“False”这些值构造器无法作用于变量。也就是说不能像调用函数那样写成写函数调用表达式。例如对于函数`f`，可以用表达式`f(x)`调用它。但是对于数字`2`，不能通过表达式`2(x)`来调用。
>
> 这实际上是一个误解。你要用`f(x)`调用函数`f`，前提是`f`得接受一元参数，并且`x`的类型要和`f`输入参数的类型一致。值构造器`2`是不接受任何输入的函数，所以不能硬塞一个参数给它。它的调用表达式就是`2`。

那么Haskell中这些词既是动词，又是名词。应该怎么区分它们什么时候作为动词，什么时候作为名词呢？

按照Lambda Calculus传下来的传统。谁能凑够参数谁就是动词，谁凑不够参数谁就是名词。而凑参数的时候要按照优先级，结合性，类型匹配等规则进行。

举个例子。`f`和`g`都是一元函数（暂时不考虑类型匹配问题）。有`f g`。按照从左往右的顺序看，`f`之后跟的`g`可以视作`f`的一个参数，而`g`后边没有其他对象，因而这里`f`是动词，`g`是名词。`f`作用于`g`。

> 你可能在想，不接受参数的构造器，例如`1`和`True`应该怎么凑参数。答案是不需要凑，它们什么时候都算调用。我们不能操作这种构造器本身，而只能操作它们返回的值。
>
> > 我一般不写注释的注释。但是这里非常有必要写一段。这里我要理清四个问题。
> >
> > 其一，在函数式编程中。函数也是值的一种。所以自然有把函数当作参数的函数。
> >
> > 其二，函数和函数的返回值是两回事。我们可以直接把两个函数加起来（例如函数复合操作），也可以把两个函数的返回值加起来。但这是两种根本不同的操作。举个例子，自增运算和自减运算的类型是`Int -> Int`。但它们的返回值类型是`Int`。而把自增和自减两个运算的返回值加起来这一操作的类型是`Int -> Int ->Int`。把自增运算和自减运算符合这个操作的类型则是`(Int -> Int) -> (Int -> Int) -> (Int -> Int)`。
> >
> > 其三，在Haskell中，我们实际上不定义任何值，只定义函数。如果需要一种新的值，我们就定义返回这种值的函数，这就是构造器。这样一来，通过对构造器施加两种用法，我们就能得到两种东西。把构造器当作名词用，我们就是指构造器这个函数本身。把构造器当作动词用，其返回值就是构造器构造的值。不过这里有一个特例，不接受任何参数输入的构造器，在Haskell的语法中实际上只能作为动词。因而，除了定义这种构造器，我们无法对这种构造器本身做任何操作。也就是说Haskell中不能运算`-> a`类型的函数。事实上Haskell在设计上根本没有想过处理这种函数，`-> a`在Haskell中被视为一种错误写法。不过这点小问题不会给我们带来多大的困扰。即使不能运算这种函数本身，Haskell仍然是图灵完备的。
> >
> > 第四，基于第三点，我们要对之前的描述做一点修改。我们并不是直接用用一些字符绑定到了抽象世界中的值。也就是说并不是用字符`2`直接绑定了抽象空间中的“两个”这一抽象概念。而是先在抽象世界中找到一个函数，它的作用是“不接受输入，返回‘两个’这一概念”。然后把字符`2`绑定到这个函数上。这么说起来好像是很麻烦。但是这对于后续理解复杂的值构造器（乃至后边的类型构造器）是非常有用的。举个例子。`Just 3`并没有直接绑定到某个值上，它是一个函数调用表达式，我们这里需要的是它的返回值。其中`Just`是类型为`a -> Maybe a`的函数。而`3`的类型是`Num p => p`。最终返回值的类型是`Num a => Maybe a`。在定义构造器`Just`的时候，我们没有直接把`Just 3`的返回值绑定到任何符号上。仅仅是构造了一个函数，然后把这个函数绑定到构造器名`Just`上。

