# Namespace

必要前驱：

- [C#](Chapter02.md)

在面向对象编程中，我们要构造很多类。并且要通过类组织程序。为了让不同的类能彼此区分，我们要给这些类起名字。为了避免重名问题。我们需要命名空间的机制。

本期的主要内容有两个——怎样的名字是合法的。以及命名空间机制。

## 合法的名称

C#对名称的要求和大多数编程语言对名称的要求一样——以字母或者下划线开头，仅仅由字母、数字、下划线构成。另外要避开一些在C#中已经有特殊含义单词（称为关键字）。

## 命名空间

名称的作用就是用于指某个类，字段，方法或者命名空间。

类是C#组织程序的基本单位。每个类肯定都是有名称的。方法，就是类中的函数。字段则是类中或者函数定义中的变量。

> 需要注意的是。一般来说字段的值都是类的实例。比如整数`4`，默认它是类`System.Int32`的一个对象。
>
> 但是方法却不能算是类或者对象。方法（或者说函数）在C#中是一个比较特殊的存在。方法就是方法，对应于语言中的动词（而类和对象对应于语言中的名词）。
>
> 不过就像语言中可以把动词变成动名词，然后当名词使用。C#中可以使用代理（delegate）把方法打包成代理对象。这样一来虽然我们不能直接把方法当作对象进行传递或运算。但是却可以把由它打包成的代理对象进行传递和运算。

而命名空间既不是类，也不是字段，更不是方法。它的意义在于防止重名。我们从一个例子开始：

在《巫师3》中。杰洛特自我介绍的时候都会说“利维亚的杰洛特”。因为小说背景中，平民是没有姓氏，只有名字的。只有贵族家族才有权力使用专有的姓氏（Triss Merigold就有姓氏，Ciri更是有一长串姓氏）。但是英文字母的组合也就那么多，其中有意义的词汇更少。人口一多难免就有重名（鸽巢原理）。这里有一个叫杰洛特的，那里也有一个叫杰洛特的。你叫一声杰洛特可能有好几个人答应。

为了防止混乱，他们会在人名的基础上加上家乡地名。“利维亚的杰洛特”就是说这个杰洛特是来自利维亚的那个。而不是疙瘩屯的那个杰洛特。（“范格堡的叶奈法”同理。）

在这一套称呼方法里，用名字加上地名。实际上加长了全名的长度，也就可以编码更多的人而不发生冲突。但是总说某某地的某某某显得太冗长。所以，一般只有在面对陌生人或者去外地的时候才报全名。如果就在当地，其实可以省略地名。比如疙瘩屯的杰洛特和疙瘩屯的叶奈法，平常在疙瘩屯的时候可以就简称杰洛特和叶奈法，反正地名都一样，没有必要增加麻烦。疙瘩屯的杰洛特只有在和利维亚的杰洛特同时出现，有混淆的可能的时候才用全称。

称呼的时候加上地名防止混淆这种方法，抽象一下就是命名空间机制。我们可能会写很多个叫`Item`的类。为了彼此区分，我们把它们放到不同的命名空间中。这样它们就有了不同的全称。比如`Database.Item`和`Network.Item`，两个`Item`分别存在于`Database`命名空间和`Network`命名空间中。

> 这里的`.`相当于“利维亚的杰洛特”中的“的”（或者英文中的“of”）。这个`.`叫做成员算符，除了访问命名空间中的类，它还能用于访问类对象或者结构体的成员。

那么写程序的时候，如何表示哪个`Item`属于哪个命名空间呢？我们首先要用关键字`namespace`，然后加上命名空间名和一对花括号。这样在这对花括号中写的一切内容都属于这个命名空间。

```C#
namespace Rivia
{
    class Geralt
    {
        
    }
    
    class Ciri
    {
        
    }
}
```

这里的两个类`Geralt`和`Ciri`就都属于`Rivia`命名空间。

> 虽然代码中两个类的全称分别是`Rivia.Geralt`和`Rivia.Ciri`。但是在命名空间内部（`namespace`后的花括号里），提到这两个类的时候，不用冠以命名空间名称。

## 命名空间的嵌套

命名空间中只能写两种东西的定义——类和命名空间。也就是说命名空间中可以嵌套命名空间。这种情况我再做一个类比。有个人叫张小三，是河北人。但是河北可能有很多叫张小三的人。称呼为“河北的张小三”也有可能造成混淆。所以我们进一步称之为“河北唐山的张小三”。这里的“唐山”就是嵌套在命名空间“河北”内部的一个命名空间。

具体看一下代码。

```C#
namespace Rivia
{
    class Geralt1{}
    
    namespace Willowhain
    {
        class Geralt2{}
    }
    
    namespace Kaveldun
    {
        class Geralt3{}
    }
}
```

要以全称访问`Geralt2`应该用`Rivia.Willowhain.Geralt2`。而要在`Geralt1`的定义中使用`Geralt2`则只需要写`Willowhain.Geralt2`。因为`Geralt1`和`Willowhain`同处于`Rivia`这个命名空间下。

> 类定义，函数定义本身也相当于建立了一个命名空间。并且当内部的本地变量和外部的变量重名时，首先认为这个名称是指内部的本地变量。

## 省略命名空间名

假设有两个命名空间`Rivial`和`Vengerberg`。在`Rivial.Geralt`的定义中要访问`Vengerberg.Yennefer`每次都要使用全名。这就非常麻烦。所以可以在代码一开始（`namespace`之前）写一行`using Vengerberg;`。这样访问所有存在于`Vengerberg`命名空间中的名称的时候，都可以省略前边的`Vengerberg`不写。比如`Vengerberg.Yennefer`就直接写成`Yennefer`。

> 要是`Rivial`和`Vengerberg`两个命名空间里各有一个`Yennefer`。并且使用了`using Vengerberg`。那么在`Rivial.Geralt`的代码中访问`Yennefer`是指哪个`Yennefer`呢？根据本地覆盖外部的原则。应当是指`Rivial.Yennefer`。

还有一种方法可以给命名空间起缩写名。同样使用`using`关键字。例如使用`using Ri = Rivial;`之后，`Rivial.Geralt`就可以简写为`Ri.Geralt`。

> `using`引导的省略命名空间名或者缩写命名空间名的代码都是语句。所以要以按C语系的习惯，用`;`作为结尾。

## 合理使用命名空间

命名空间当然是一种避免名称冲突的机制。但是实际上我们也可以把命名空间当作一种代码组织方式。比如把命名空间当作组织模块的方法，被放到同一个命名空间中的类，都是功能上相关或者相近的。C#标准库中的工具就大部分都放到了`System`命名空间。

> 所有命名空间处于一个更大的命名空间中。只不过这个命名空间是默认的，我们也不能给它改名字。
>
> 如果没有本地变量（或者本地子命名空间）重名覆盖等问题。所有我们定义的命名空间名是应该可以任何地方都能访问的。（因为所有代码实质上都处于那个默认的，不用起名字的，最大的命名空间的作用域中。）

## 命名

不论是变量还是函数，类还是命名空间，一般来说都要给它们起个名字来方便彼此分辨。C#中，给这些东西起名字的规则和其他语言中类似：

- 以字母或下划线开头。
- 由字母，下划线或者数字组成。
- 不能和关键字重复。

> 所谓的“关键字”（我更倾向于叫“关键词”）是一些拥有语法意义的单词。为了防止含义冲突，这些词是不能作为变量、函数、类或者命名空间的名称的。

> 不能以数字开头，是为了防止变量名称和数字的字面值发生混淆。相当于通过开头字符将数字字面值和变量名分开。需要注意的是，数字字面值中并不一定不包含字母，例如十六进制的数字`0x12AB`。

### 命名规范

C#中主要使用两种命名风格：

- Pascal Case，名称中每一个单词首字母都大写（单词之间没有下划线空隙）。例如`PascalCase`。
- Camel Case，首字母小写，其他写法同Pascal Case。例如`camelCase`。

一般来说C#中的类和方法名使用Pascal Case，其他变量（对象实例）使用Camel Case命名。

