# Semantic Versioning

Semantic Versioning，语义化版本号，简称“SemVer”。是一种格式化的版本号规则。并且版本号中各个部分的含义被加以了限制。这一套规则，是为了改善各种软件版本号格式混乱，语义不明的现状而提出的。

Semantic Versioning标准的官网兼说明页面是<https://semver.org/>。

## 由来

为了修复Bug，增加新功能或者改变软件特性，软件的开发者和维护者会不断推出新版本的软件。为了区分同一个软件的不同版本，人们会给每一个软件版本一个代号。这样软件名加版本代号就能明确指定某个软件的某个版本。

但是，版本号的格式大部分时间是按开发者的喜好指定的。比如有的软件版本号就是一个自然数。每改版一次，版本号增加1。有的开发者则用点分隔的多个自然数表示版本（比如Minecraft Forge的版本号`14.23.5.2784`）。靠左的数变动表示大版本更新，靠右的数变动表示小版本更新或者补丁更新。还有的开发者喜欢混用单词和数字（比如Minecraft的`1.6.3-pre`）。还有可能有的开发者会使用非常复杂的版本计算方式（比如Minecraft现在正式版用数字号`1.14`，预览版用一些和乱码差不多的代号`18w47a`）。奇葩的高纳德则用无理数的渐近值作为TeX的版本号（现在排到了`3.14159265`）。

这些五花八门的版本号给软件交流造成了很大的麻烦。你看到一个版本号，就是一个版本号而已，并不能从中得出更多信息。甚至有时候你不能从数字的大小判断出版本的现后。（谁来告诉我Minecraft的`Beta-1.8`，`1.8`，`14w02a`到底什么关系？）

在用软件自动处理版本依赖的时候更是头疼。因为版本号的处理要基于字符串格式解析。一个软件一个版本号格式，得写多少字符串解析函数啊……（Minecraft这种软件还有很多种版本号格式……）

## 语义化版本号

语义化版本号SemVer，是一个标准。这个标准旨在解决版本号格式混乱的问题，顺便统一一下版本号所表达的含义。简单来说一个SemVer版本号主要由三个部分组成。每个部分都是一个非负整数。不同部分之间由`.`分隔。从左到右三个部分分别表示：

1. 主版本号：每当进行非向下兼容的修改或者颠覆性的更新时，主版本号加1。
1. 次版本号：每当进行向下兼容的修改或者添加兼容性的新功能时，次版本号加1。
1. 补丁号：没有新功能的引入，仅仅是打一些兼容性补丁，做一些兼容性修复时，补丁号加1。

### 从0开始

当主版本号更新时，次版本号和补丁号都要归零。次版本号更新时补丁号归零。

主版本号也可以从0开始。但是当主版本号为0时一般表示目前软件处于预开发阶段。而当主版本号为1时，表示软件的第一个完整能用的版本。

> 版本号中三个部分不存在“进位”问题。`1.10.100`这种版本号也是完全合乎规范的。

### 比较大小

语义化版本号是可以比较大小的。比较的时候先比主版本，主版本大的那个版本号比较大。主版本相同继续比次版本。次版本还相同继续比补丁号。

举个例子：`1.24.3`<`2.0.1`<`2.4.1`<`2.4.2`。

> 版本号的大小仅仅表示软件版本，软件功能上的顺序关系。不一定版本号大的版本发布时间就比版本号小的版本发布时间晚。比如Python在推出3之后还给Python2打了几个补丁。这几个补丁的版本号比Python3的版本号小，但是却是在Python3之后开发发布的。

### 向哪兼容？

向某个方向兼容这种说法经常会导致混淆。参考维基百科上的说法[^1]，“向下兼容”和“向后兼容”是一回事。并且向下兼容表示版本号大的软件兼容版本号小的软件的全部功能。例如Word 2013能打开Word 2003的文档，Python3.6能运行Python3.5的脚本，这就叫向下兼容。而Python3.0不能运行Python2.7的脚本这就叫向下不兼容。

### 预览版号

一个正式版（或者稳定版）的版本号就由之前介绍的三部分组成。但是在开发流程中开发者经常要在一个版本上线之前做一些测试性版本。这些版本可以通过在正式版号后加连词符以及字符串的方式来编号。例如`1.2.1-alpha`，`1.2.1-beta`，`1.2.1-rc.1`。

这些预览版版本号也是可以排序的，一般来说所有预览版小于它们对应的正式版，但是大于前一个正式版本。预览版之间比较则一般按照`alpha`，`beta`，`rc`的顺序排序。有时候可能测试阶段还做了好几版，那么同一阶段，带数字的测试版按数字排序，不带数字的测试版版号最小。例如：`1.2.0`<`1.2.1-alpha`<`1.2.1-alpha.1`<`1.2.1-alpha.2`<`1.2.1-beta`<`1.2.1-rc.1`<`1.2.1`。

> alpha，beta，gamma表示三个测试阶段。而rc表示“Release Candidate”。一般来说应当先经过三个测试阶段（有时候只有alpha和beta测试），再进入rc阶段。rc阶段的不同版本可以没有时间上或者逻辑上的现后关系，同时作为正式版的候选。严格按照这个说法来做的话`1.1.0-rc.1`和`1.1.0-rc.2`应当属于既不等于，也不大于，也不小于的“并列”关系。但是这样处理起来逻辑关系就很复杂了，况且这还不是SemVer中定义的内容。因此实际上用一些工具包处理语义版本号的时候，不一定会把不同的rc版本处理成并列关系。比如后边的Python包semver中，`1.1.0-rc.1`小于`1.1.0-rc.2`。

## 实现

Semantic Versioning只是一个标准，而没有提供实现。虽然自己实现一个也不复杂，但是有轮子用为啥还要造呢？

Python内置的`distuitls.version`就可以进行版本号比较等操作。但是不知道为什么这玩意没有说明文档[^2][^3]。

![坑爹呢这是](http://image.bee-ji.com/127684)

因此我推荐使用PyPI上的Python包[semver](https://pypi.org/project/semver/)。这个Python包提供了语义版本号的解析，运算和比较功能。而且提供了一份完整的文档说明。对比官方内置类包都没有文档的现状来看，这点真是难能可贵。

> semver可以通过pip下载安装，也可以通过Conda下载安装。

---

参考和引用

[^1]: https://en.wikipedia.org/wiki/Backward_compatibility
[^2]: https://stackoverflow.com/questions/11887762/how-do-i-compare-version-numbers-in-python
[^3]: https://docs.python.org/3/distutils/apiref.html#module-distutils.version

